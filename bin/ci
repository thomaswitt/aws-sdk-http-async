#!/usr/bin/env ruby

require 'net/http'
require 'open3'
require 'socket'

class CIRunner
  def initialize
    @steps = []
    @failed = false
  end

  def step(name, command)
    @steps << { name:, command: }
  end

  def run
    puts "Running CI checks...\n\n"
    start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)

    @steps.each do |step|
      run_step(step[:name], step[:command])
      break if @failed
    end

    elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start_time
    puts "\n#{'=' * 60}"
    if @failed
      puts "CI FAILED after #{elapsed.round(2)}s"
      exit 1
    else
      puts "CI PASSED in #{elapsed.round(2)}s"
    end
  end

  private

  def run_step(name, command)
    print "#{name}... "
    $stdout.flush
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    stdout, stderr, status = Open3.capture3(command)
    elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start

    if status.success?
      puts "OK (#{elapsed.round(2)}s)"
    else
      puts "FAILED (#{elapsed.round(2)}s)"
      puts "\n#{'-' * 60}"
      puts "Command: #{command}"
      puts "STDOUT:\n#{stdout}" unless stdout.empty?
      puts "STDERR:\n#{stderr}" unless stderr.empty?
      puts '-' * 60
      @failed = true
    end
  end
end

def docker_compose_available?
  system('docker', 'compose', 'version', out: File::NULL, err: File::NULL)
end

def wait_for_dynamodb(endpoint, attempts: 60, delay: 2)
  uri = URI(endpoint)
  attempts.times do |attempt|
    begin
      Net::HTTP.start(uri.host, uri.port) { |http| http.head('/') }
      puts "DynamoDB Local is ready"
      return true
    rescue StandardError
      puts "DynamoDB not ready yet (attempt #{attempt + 1}/#{attempts})"
      sleep delay
    end
  end
  false
end

def wait_for_minio(endpoint, attempts: 60, delay: 2)
  uri = URI("#{endpoint}/minio/health/live")
  attempts.times do |attempt|
    begin
      response = Net::HTTP.get_response(uri)
      if response.is_a?(Net::HTTPSuccess)
        puts "MinIO is ready"
        return true
      end
    rescue StandardError
      nil
    end
    puts "Waiting for MinIO (attempt #{attempt + 1}/#{attempts})"
    sleep delay
  end
  false
end

def wait_for_tinyproxy(host, port, attempts: 60, delay: 2)
  attempts.times do |attempt|
    begin
      socket = TCPSocket.new(host, port)
      socket.close
      puts "tinyproxy is ready"
      return true
    rescue StandardError
      puts "Waiting for tinyproxy (attempt #{attempt + 1}/#{attempts})"
      sleep delay
    end
  end
  false
end

def wait_for_toxiproxy(endpoint, attempts: 60, delay: 2)
  uri = URI("#{endpoint}/version")
  attempts.times do |attempt|
    begin
      response = Net::HTTP.get_response(uri)
      if response.is_a?(Net::HTTPSuccess)
        puts "toxiproxy is ready"
        return true
      end
    rescue StandardError
      nil
    end
    puts "Waiting for toxiproxy (attempt #{attempt + 1}/#{attempts})"
    sleep delay
  end
  false
end

ci = CIRunner.new
ci.step 'Bundle check', 'bundle check'
ci.step 'Style: Rufo', 'bundle exec rake rufo:check'
ci.step 'Style: RuboCop', 'bundle exec rubocop --format simple'
if File.exist?('config/application.rb')
  ci.step 'Security: Brakeman code analysis',
    'bundle exec brakeman --rails8 --run-all-checks --quiet --no-pager --no-summary -i .brakeman-ignore.json'
else
  ci.step 'Security: Brakeman code analysis', 'echo "Brakeman skipped (no Rails app)"'
end

docker_enabled = docker_compose_available? && File.exist?('docker-compose.yml')
docker_services_started = false
if docker_enabled
  if ENV['AWS_SDK_HTTP_ASYNC_DOCKER_STARTED'] != '1'
    puts 'Starting docker services...'
    system('docker', 'compose', 'up', '-d') || exit(1)
    docker_services_started = true
  end

  at_exit do
    next unless docker_services_started

    system('docker', 'compose', 'down')
  end

  unless wait_for_dynamodb('http://localhost:8011')
    warn 'DynamoDB Local did not become ready in time'
    exit 1
  end

  unless wait_for_minio('http://localhost:9010')
    warn 'MinIO did not become ready in time'
    exit 1
  end

  unless wait_for_tinyproxy('127.0.0.1', 8888)
    warn 'tinyproxy did not become ready in time'
    exit 1
  end

  unless wait_for_toxiproxy('http://localhost:8474')
    warn 'toxiproxy did not become ready in time'
    exit 1
  end
end

ci.step 'Tests: RSpec', "bundle exec rspec --tag '~docker'"
ci.step 'Tests: Docker integration', 'bundle exec rspec --tag docker' if docker_enabled
ci.step 'Security: Bundler audit', 'bundle exec bundle-audit check --update'
ci.run
